<h2><div class="hyperlogoalone" id="stores"><%= image_tag "HyperStores.png", width: '35'%></div>
Stores
</h2>

Hyperloop Stores (similar to Flux Stores) exist to hold local application state. Components read state from Stores and render accordingly. This separation of concerns is an improvement in the overall architecture and makes our application easier to maintain.

**Why would we have Stores?** Let's examine that question through an example.

### Overloaded Components

Take the simple Component below which displays an initial discount then gives the user the option of taking a once only 'Lucky Dip' that will either increase or decrease their discount.

```ruby
class OfferLuckyDip < Hyperloop::Component
  state discount: 30
  state lucky_dip_taken: false

  def render
    DIV do
      H1 {"Your discount is #{state.discount}%"}
      BUTTON { "Lucky Dip" }.on(:click) do
        state.discount! (state.discount + rand(-5..5))
        state.lucky_dip_taken! true
      end unless state.lucky_dip_taken
    end
  end
end
```

The Component will work as expected but there are two fundamental problems with this pattern:

+ Firstly, the discount (state) is tied to the Component itself. This is a problem as we might have other Components on the page which need to also see and interact with the discount. **We need a better place than in our Components to keep application state.**
+ Our business logic (discounts start at 30% and the lucky dip increases or decreases by 5%) is all wrapped up with our presentational code. This makes our application fragile and difficult to evolve. **Our application logic should be separate from our display logic.**

We will fix these problems but first implementing a Hyperloop Store to keep our application state and business logic out of our Components. Later in this guide we will go one step further and move our business logic out of the Store into an Operation but for now the first step will be a big improvement.

### Using Stores

First let's add the Store:


You will notice a few things in the code above:

+ A Store is a ruby class derived from `Hyperloop::Store`
+ We have added two state variables which are both scoped to be class variables meaning that we will only have one instance of this class
+ Similarly the `lucky_dip!` method is a class method
+ Notice how we use `mutate` to change the value of a state variable.

Next we will refactor our Component to use the Store:

<div class="codemirror-live-edit"
  data-heading="An overloaded Component"
  data-rows=22
  data-top-level-component="OfferLuckyDip">
<pre>
class Discounter < Hyperloop::Store
   state discount: 30, scope: :class, reader: true
   state lucky_dip_taken: false, scope: :class, reader: true

  def self.lucky_dip!
    mutate.discount( state.discount + rand(-5..5) )
    mutate.lucky_dip_taken true
  end
end

class OfferLuckyDip < Hyperloop::Component
  def render
    DIV do
      H1 {"Your discount is #{Discounter.discount}%"}
      BUTTON { "Lucky Dip" }.on(:click) do
        Discounter.lucky_dip!
      end unless Discounter.lucky_dip_taken
    end
  end
end
</pre></div>

+ Notice that we do not create an instance of the Discounter class but instead access the class methods of the Store `Discounter.lucky_dip!` so that all Components will be using the same 'class instance' of the Store.
+ `Discounter.discount` is a reader class method that was added to the Store for us by `state discount: 30, scope: :class, reader: true` which saved us a lot of typing!
+ Components that read a Store's state will automatically update when the state changes.

Stores can also receive dispatches from Operations - we will come to that later in this overview. In Hyperloop it is perfectly legitimate to interact with a Store through its class methods as we have done above.

That concludes the introduction to Stores. To learn more about Stores please see the [Tutorials](/tutorials) and also the comprehensive [Docs](/docs/architecture)

------------------------------------
<h2><div class="hyperlogoalone" id="models"><%= image_tag "HyperModels.png", width: '35'%></div>
Models
</h2>

Hyperloop Models give your access to your server side Rails ActiveRecord Models from the client. In addition, Hyperloop implements push notifications (via a number of possible technologies) so changes to records on the server are dynamically pushed to all authorized clients.

+ No need for a boilerplate API just to move JSON between the client and server
+ Changes are automatically synchronized between connected clients
+ You do not need to maintain one Model for the server and one Model for the client

**One set of Models used by the client and the server code. Isomorphic Ruby in action.**

Models act like Stores in that they contain state, which is linked to the underlying ActiveRecord Models on the server. Changes make to the server-side Models are pushed to the client depending on the configured Policy for the current user.

### ActiveRecord Models

Our Models are linked to ActiveRecord Models so for this part of the Hyperloop architecture we have a dependancy on Rails and Active Record. If you are not using Rails you can still take advantage of Hyperloop's Components & Stores (which do not depend on Rails) to create stunning interactive user interfaces.

Let's assume we have an ActiveRecord Model called Books:

```ruby
class Book < ApplicationRecord
end
```
