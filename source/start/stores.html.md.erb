<h2><div class="hyperlogoalone" id="stores"><%= image_tag "HyperStores.png", width: '35'%></div>
Stores
</h2>

Hyperloop Stores (similar to Flux Stores) exist to hold local application state. Components read state from Stores and render accordingly. This separation of concerns is an improvement in the overall architecture and makes your application easier to maintain.

**Why would we have Stores?** Let's examine that question through an example.

### Overloaded Components

Take the simple Component below which displays an initial discount then gives the user the option of taking a once only 'Lucky Dip' that will either increase or decrease their discount.

```ruby
class OfferLuckyDip < Hyperloop::Component
  state discount: 30
  state lucky_dip_taken: false

  def render
    DIV do
      H1 {"Your discount is #{state.discount}%"}
      BUTTON { "Lucky Dip" }.on(:click) do
        mutate.discount(state.discount + rand(-5..5))
        mutate.lucky_dip_taken true
      end unless state.lucky_dip_taken
    end
  end
end
```

The Component will work as you would expect but there are two fundamental problems with this design:

+ Firstly, the discount (state) is tied to the Component itself. This is a problem as we might have other Components on the page which need to also see and interact with the discount. **We need a better place than in our Components to keep application state.**
+ Our business logic (discounts start at 30% and the lucky dip increases or decreases by 5%) is all wrapped up with our presentational code. This makes our application fragile and difficult to evolve. **Our application logic should be separate from our display logic.**

We will fix these problems but first implementing a Hyperloop Store to keep our application state and business logic out of our Components. Later in this overview we will go one step further and move our business logic out of the Store into an Operation but for now the first step will be a big improvement.

### Using Stores

First let's add the Store and refactor our Component to use the Store:

<div class="codemirror-live-edit"
  data-heading="An overloaded Component"
  data-rows=22
  data-top-level-component="OfferLuckyDip">
<pre>
class Discounter < Hyperloop::Store
   state discount: 30, scope: :class, reader: true
   state lucky_dip_taken: false, scope: :class, reader: true

  def self.lucky_dip!
    mutate.discount( state.discount + rand(-5..5) )
    mutate.lucky_dip_taken true
  end
end

class OfferLuckyDip < Hyperloop::Component
  def render
    DIV do
      H1 {"Your discount is #{Discounter.discount}%"}
      BUTTON { "Lucky Dip" }.on(:click) do
        Discounter.lucky_dip!
      end unless Discounter.lucky_dip_taken
    end
  end
end
</pre></div>

You will notice a few things in the code above:

+ A Store is a ruby class derived from `Hyperloop::Store`
+ We have added two state variables which are both scoped to be class variables meaning that we will only have one instance of this class
+ Similarly the `lucky_dip!` method is a class method
+ Notice how we use `mutate` to change the value of a state variable.
+ We do not create an instance of the Discounter class but instead access the class methods of the Store `Discounter.lucky_dip!` so that all Components will be using the same 'class instance' of the Store.
+ `Discounter.discount` is a reader class method that was added to the Store for us by `state discount: 30, scope: :class, reader: true` which saved us a lot of typing!
+ Components that read a Store's state will automatically update when the state changes.

Stores can also receive dispatches from Operations - we will come to that later in this overview. In Hyperloop it is perfectly legitimate to interact with a Store through its class methods as we have done above.

That concludes the introduction to Stores. To learn more about Stores please see the [Tutorials](/tutorials) and also the comprehensive [Docs](/docs/architecture)

------------------------------------

<button type="button" class="btn btn-primary btn-lg btn-hyperlooppink" onclick="location.href='/start/models';">Next we cover Models</button>
