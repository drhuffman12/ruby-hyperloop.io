<h1><div class="hyperlogoalone" id="operations"><%= image_tag "HyperOperations.png", width: '50'%></div>
<div class="chaptertitle"><span class="bigfirstletter">O</span>perations</div>
</h1>

Operations are the engine rooms of Hyperloop. They drive processes and they orchestrate events. Operations orchestrate the interactions between components, external services and stores. **Operations are where your business logic lives.**

In a traditional MCV architecture, there is no defined place to keep business logic. You can overload your Controllers, Views or Models and (unless you follow a defined pattern like Trailblazer) you generally end up with your business logic all over the place. Our vision of building a 'Complete Ruby Isomorphic Framework' meant that we had to address that problem head on, so we created Operations.

The design of our Operations has been inspired by a few sources:

+ We liked the way the [Mutations Gem](https://github.com/cypriss/mutations) handles parameters and validation
+ [Trailblazer](https://github.com/trailblazer/trailblazer#operation) inspired the idea of Operations and we like the `validate` and `step` methods
+ The [Flux](https://facebook.github.io/flux/) pattern taught us that unidirectional data flow is a good idea and Stores should be able to `receive` dispatches from Operations

**Operations execute on the clients or the server.** This simple principal radically simplifies application design and testing.

Hyperloop Operations work in three ways:

1. They `run` a sequence of `step`'s. Each step is a progressive step in a workflow, only continuing to the next step if the current step proceeds. This mode borrows from Trailblazer's concept of an Operation.
2. Much like Flux Actions, Stores can `receive` Operations so a Store can look out for an Operation being run and act accordingly. This shifts the responsibility to the Store to look out for an Operation being run.
3. `ServerOps` are Operations which, to your Isomorphic code, look like normal Operations but are guaranteed to only run on the server, even when they are invoked from the client. A good reason for this type of Operation would be when resources needed by the Operation are bound to the server - for example invoking a Mailer or updating a database. ServerOps do away with the need for an API layer (unless you specifically want an API).

### 1. Operations with Steps

Stores hold state and Operations orchestrate the mutation of state. In the Store section, we demonstrated how a class method on the Store could be used to mutate the state. In this example, we will have an Operation mutate the Store's state:

<div class="codemirror-live-edit"
  data-heading="Operations with steps"
  data-rows=28
  data-top-level-component="OfferLuckyDip">
<pre>
class Discounter < Hyperloop::Store
   state discount: 30, scope: :class, reader: true
   state tries: 0, scope: :class, reader: true
  def self.lucky_dip!
    mutate.discount( state.discount + rand(-5..5) )
    mutate.tries(state.tries + 1)
  end

  class LuckyDipOp < Hyperloop::Operation
    def check_tries
      abort! if Discounter.tries > 2
    end
    step { check_tries }
    step { Discounter.lucky_dip! }
  end
end

class OfferLuckyDip < Hyperloop::Component
  def render
    DIV do
      H1 {"Your discount is #{Discounter.discount}%"}
      BUTTON { "Lucky Dip" }.on(:click) do
        Discounter.LuckyDipOp
      end
    end
  end
end
</pre></div>

You will notice in the code above:

+ This approach is very similar to simply adding a method to the Store to mutate the state, but there are some advantages. Firstly, we can take advantage of the validation of incoming params and secondly we can use `step`'s to ensure that each part of the operation only executes if the previous part was successful
+ The LuckyDipOp Operation is included in the Store's namespace. This is optional but a good way to group Operations with the Stores they operate on

### Dispatchers and Receivers

Next we will write an Operation for login the user out which will dispatch a message that our ShoppingCart will receive. This will be following a Flux pattern.

**All Operations dispatch but it up to a Store to receive a dispatch.** We have implemented the Flux pattern into Operations and Stores. Operations are dispatchers and Stores are receivers.


XXX

### Server Operations

There are some Operations that simply do not make sense to run on the client as (for example) the resources they depend on may not be available on the client. Consider an Operation that needs to send an email - there is no mailer on the client so the Operation has to execute from the server.

That said, with our highest goal being developer productivity, it should be as invisible as possible to the developer where the Operation will execute. To complete the example, a developer writing front-end code should be able to invoke a server-side resource (like a mailer) just as easily as they might invoke a client-side resource.

**ServerOps execute only on the server but are invokable from your Isomorphic code** No need for boilerplate APIs just to execute a server side Operation. ServerOps are just like any normal Operations and invokable from any part of your code.

Finally we will use a server Operation to sign a user up to a mailing list and send them an email. This will show how to use ServerOps and also how `step` works.

XXX



```ruby
class Discounter < Hyperloop::Store
   state discount: 30, scope: :class, reader: true
   state lucky_dip_taken: false, scope: :class, reader: true

  # Note these two lines are essentially "noise" at this point, however
  # they will future proof the API.    They also provide a very clear declaration
  # of the API.
  class LuckyDip < Hyperloop::Operation; end
  class Bumper < Hyperloop::Operation; end
end

# we can take advantage of the way Ruby deals with classes and close the the
# class definition above as the 'public' interface, and open the class up in another
# file (if we want)

class Discounter

  # likewise because Operations are classes we can open them up here and add implementation:

  class LuckyDip < Hyperloop::Operation
    outbound :dip_or_slip
    validate { !Discounter.lucky_dip_taken }
    fail { puts '**** attempted to take two lucky dips *****' }
    step { params.dip_or_slip = rand(-5..5) }
    # or for more fun we could of course make it a ServerOp and grab the lucky dip based on
    # some global algorithm ensuring the luck dip average across all users 0
  end

  receives LuckyDip do |params|
    mutate.discount( state.discount + params.dip_or_slip )
    mutate.lucky_dip_taken true
  end

  receives Bumper do
    mutate.discount( state.discount * 10 )
  end
end

class OfferLuckyDip < Hyperloop::Component
  def render
    DIV do
      H1 {"Your discount is #{Discounter.discount}%"}
      BUTTON { "Lucky Dip" }.on(:click) do
        Discounter::LuckyDip.run # note should be able to say Discounter::LuckyDip() but there is a bug :-)
      end unless Discounter.lucky_dip_taken
    end
    BUTTON { "Bump" }.on(:click) do
      Discounter::Bumper.run
    end
  end
end
```

--------------------

<button type="button" class="btn btn-primary btn-lg btn-hyperlooppink" onclick="location.href='/start/models';">Next we cover Models</button>
