<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv='X-UA-Compatible' content='IE=edge;chrome=1' />
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

    <meta name="google-site-verification" content="qjqVOvRhHfsuDbLOvaAnj2mkUZJ9Xwzg84TMVXduvUc" />

    <meta charset="UTF-8">
    <title>Hyperloop - Hyper-Mesh Docs</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>

    <!-- <link href="/stylesheets/base.css" rel="stylesheet" />
    <link href="/stylesheets/normalize.css" rel="stylesheet" />
    <link href="/stylesheets/stylesheet.css" rel="stylesheet" />
    <link href="/stylesheets/github-light.css" rel="stylesheet" /> -->

    <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/marked/0.3.5/marked.min.js"></script>
    <script src="https://rawgit.com/reactrb/reactrb-express/master/reactrb-express.js"></script>

    <script src="https://npmcdn.com/tether@1.2.4/dist/js/tether.min.js"></script>

    <script src="/javascripts/bootstrap.min.js"></script>
    <script src="/javascripts/codemirror.js"></script>
    <script src="/javascripts/ruby.js"></script>
    <script src="/javascripts/matchbrackets.js"></script>

    <link href="/stylesheets/bootstrap.min.css" rel="stylesheet" />
    <link href="/stylesheets/override.css" rel="stylesheet" />
    <!-- <link href="/stylesheets/code.css" rel="stylesheet" /> -->
    <link href="/stylesheets/github.css" rel="stylesheet" />
    <link href="/stylesheets/highlighting.css" rel="stylesheet" />
    <link href="/stylesheets/codemirror.css" rel="stylesheet" />

    <link rel="alternate" type="application/atom+xml" title="Atom Feed" href="/feed.xml" />

    <!-- Favicons -->
    <link rel="apple-touch-icon" sizes="57x57" href="/images/apple-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="60x60" href="/images/apple-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/images/apple-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="/images/apple-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/images/apple-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="/images/apple-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="/images/apple-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/images/apple-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-icon-180x180.png">
    <link rel="icon" type="image/png" sizes="192x192"  href="/images/android-icon-192x192.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="96x96" href="/images/favicon-96x96.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
    <link rel="manifest" href="/manifest.json">
    <meta name="msapplication-TileColor" content="#ffffff">
    <meta name="msapplication-TileImage" content="/images/ms-icon-144x144.png">
    <meta name="theme-color" content="#ffffff">

  </head>

  <body>
    <div class="container">
      <nav class="navbar navbar-ligh">
  <button class="navbar-toggler hidden-sm-up" type="button" data-toggle="collapse" data-target="#exCollapsingNavbar2" aria-controls="exCollapsingNavbar2" aria-expanded="false" aria-label="Toggle navigation">
    &#9776;
  </button>
  <div class="collapse navbar-toggleable-xs" id="exCollapsingNavbar2">
    <ul class="nav navbar-nav">
      <li class="nav-item">
        <a href="/" class="nav-link">Hyperloop</a>
      </li>
      <li class="nav-item">
        <a href="/get_started" class="nav-link active">Get Started</a>
      </li>
      <li class="nav-item">
        <a href="/tutorials" class="nav-link">Tutorials</a>
      </li>
      <li class="nav-item">
        <a href="/installation" class="nav-link">Installation</a>
      </li>
      <li class="nav-item">
        <a href="/gems" class="nav-link">Gems</a>
      </li>
      <li class="nav-item">
        <a href="https://github.com/ruby-hyperloop" class="nav-link">Github</a>
      </li>
      <li class="nav-item">
        <a href="/tools" class="nav-link">Tools</a>
      </li>
      <li class="nav-item">
        <a href="/docs/dsl_overview" class="nav-link">Docs</a>
      </li>
      <li class="nav-item">
        <a href="/support" class="nav-link">Support</a>
      </li>
      <li class="nav-item">
        <a href="/blog" class="nav-link">Blog</a>
      </li>
    </ul>
  </div>
</nav>

    </div>

    <div class="jumbotron page-header">
      <div class="container">
        <div class="row hidden-xs-down">
          <div class="col-md-3 center-text">
            <img src="/images/hyperloop_white.svg" width="180" alt="Hyperloop white" />
          </div>
          <div class="col-md-9">
            <h1 class="display-4 project-name">Hyperloop</h1>
            </br>
            <h2 class="display-7 project-tagline">
              HYPER-MESH DOCS
            </h2>
          </div>
        </div>
        <div class="row hidden-sm-up">
          <div class="col-md-3 center-text">
            <img src="/images/hyperloop_white.svg" width="120" alt="Hyperloop white" />
          </div>
          <div class="col-md-9">
            <h1 class="h1 project-name center-text">Hyperloop</h1>
            </br>
            <h2 class="h4 project-tagline center-text">
              HYPER-MESH DOCS
            </h2>
          </div>
        </div>
      </div>
    </div>

    <div class="container">
      <div class="row">
        <div class="col-md-3">
            <ul class="nav">
    <li class="nav-item"><strong><a href="/docs/dsl_overview">HyperReact Overview</a></strong></br></li>
    <li class="nav-item"><a href="/docs/components_and_state">Components and State</a></br></li>
    <li class="nav-item"><a href="/docs/lifecycle_callbacks">Lifecycle Callbacks</a></br></li>
    <li class="nav-item"><a href="/docs/lifecycle_methods">Lifecycle Methods</a></br></li>
    <li class="nav-item"><a href="/docs/event_handelers">Event Handelers</a></br></li>
    <li class="nav-item"><a href="/docs/elements_rendering">Elements and Rendering</a></br></li>
    <li class="nav-item"><a href="/docs/javascript_components">Javascript Components</a></br></li>
    <li class="nav-item"><a href="/docs/further_reading">Further Reading</a></br></li>
  </ul>
  <br>
  <ul class="nav">
    <li class="nav-item"><strong><a href="/docs/hypermesh_overview">HyperMesh Overview</a></strong></li>
    <li class="nav-item"><a href="/docs/hypermesh_active_record">ActiveRecord API</a></br></li>
    <li class="nav-item"><a href="/docs/hypermesh_scoping">Scoping</a></br></li>
    <li class="nav-item"><a href="/docs/hypermesh_authorization">Authorization</a></br></li>
    <li class="nav-item"><a href="/docs/hypermesh_debugging">Debugging</a></br></li>
  </ul>

          <br>
        </div>
        <div class="col-md-9 main-content">
          <h2 id="client-side-scoping">Client Side Scoping</h2>

<p>By default scopes will be recalculated on the server.  For simple scopes that do not use joins or includes no additional action needs to be taken to make scopes work with HyperMesh.  For scopes that do use joins, or if you want to offload the scoping computation from the server to the client read this section.</p>

<h2 id="activerecord-scope-enhancement">ActiveRecord Scope Enhancement</h2>

<p>When the client receives notification that a record has changed HyperMesh finds the set of currently rendered scopes that might be effected, and requests them to be updated from the server.  </p>

<p>On the server scopes are a useful way to structure code.  <strong>On the client</strong> scopes are vital as they limit the amount of data loaded, viewed, and updated in the browser.  Consider a factory floor management system that shows <em>job</em> state as work flows through the factory.  There may be millions of jobs that a production floor browser is authorized to view, but at any time there are probably only 50 being shown.  Using ActiveRecord scopes is the way HyperMesh keeps the data requested by the browser limited to a reasonable amount.  </p>

<p>To make scopes work efficiently on the client HyperMesh adds some features to the ActiveRecord <code>scope</code> and <code>default_scope</code> macros.  Note you must use the <code>scope</code> macro (and not class methods) for things to work with HyperMesh.</p>

<p>The additional features are accessed via the <code>:joins</code>, <code>:client</code>, and <code>:select</code> options.</p>

<p>The <code>:joins</code> option tells the HyperMesh client which models are joined with the scope.  <em>You must add a <code>:joins</code> option if the scope has any data base join operations in it, otherwise if a joined model changes, HyperMesh will not know to update the scope.</em></p>

<p>The <code>:client</code> and <code>:select</code> options provide the client a way to update scopes without having to contact the server.  Unlike the <code>:joins</code> option this is an optimization and is not required for scopes to work.</p>
<pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">Todo</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>

  <span class="c1"># Standard ActiveRecord form:</span>
  <span class="c1"># the proc will be evaluated as normal on the server, and as needed updates</span>
  <span class="c1"># will be requested from the clients</span>

  <span class="n">scope</span> <span class="ss">:active</span><span class="p">,</span> <span class="o">-&gt;</span> <span class="p">()</span> <span class="p">{</span> <span class="n">where</span><span class="p">(</span><span class="ss">completed: </span><span class="kp">true</span><span class="p">)</span> <span class="p">}</span>

  <span class="c1"># In the simple form the scope will be reevaluated if the model that is</span>
  <span class="c1"># being scoped changes, and if the scope is currently being used to render data.</span>

  <span class="c1"># If the scope joins with other data you will need to specify this by</span>
  <span class="c1"># passing a relationship or array of relationships to the `joins` option.</span>

  <span class="n">scope</span> <span class="ss">:with_recent_comments</span><span class="p">,</span>
        <span class="o">-&gt;</span> <span class="p">{</span> <span class="n">joins</span><span class="p">(</span><span class="ss">:comments</span><span class="p">).</span><span class="nf">where</span><span class="p">(</span><span class="s1">'comment.created_at &gt;= ?'</span><span class="p">,</span> <span class="no">Time</span><span class="p">.</span><span class="nf">now</span><span class="o">-</span><span class="mi">1</span><span class="p">.</span><span class="nf">week</span><span class="p">)</span> <span class="p">},</span>
        <span class="ss">joins: </span><span class="p">[</span><span class="s1">'comments'</span><span class="p">]</span> <span class="c1"># or joins: 'comments'</span>

  <span class="c1"># Now with_recent_comments will be re-evaluated whenever a Todo record, or a Comment</span>
  <span class="c1"># joined with a Todo change.</span>

  <span class="c1"># Normally whenever HyperMesh detects that a scope may be effected by a changed</span>
  <span class="c1"># model, it will request the scope be re-evaluated on the server.  To offload this</span>
  <span class="c1"># computation to the client provide a client side scope method:</span>

  <span class="n">scope</span> <span class="ss">:with_recent_comments</span><span class="p">,</span>
        <span class="o">-&gt;</span> <span class="p">{</span> <span class="n">joins</span><span class="p">(</span><span class="ss">:comments</span><span class="p">).</span><span class="nf">where</span><span class="p">(</span><span class="s1">'comment.created_at &gt;= ?'</span><span class="p">,</span> <span class="no">Time</span><span class="p">.</span><span class="nf">now</span><span class="o">-</span><span class="mi">1</span><span class="p">.</span><span class="nf">week</span><span class="p">)</span> <span class="p">},</span>
        <span class="ss">joins: </span><span class="p">[</span><span class="s1">'comments'</span><span class="p">]</span>
        <span class="ss">client: </span><span class="o">-&gt;</span> <span class="p">{</span> <span class="n">comments</span><span class="p">.</span><span class="nf">detect</span> <span class="p">{</span> <span class="o">|</span><span class="n">comment</span><span class="o">|</span> <span class="n">comment</span><span class="p">.</span><span class="nf">created_at</span> <span class="o">&gt;=</span> <span class="no">Time</span><span class="p">.</span><span class="nf">now</span><span class="o">-</span><span class="mi">1</span><span class="p">.</span><span class="nf">week</span> <span class="p">}</span>

  <span class="c1"># The client proc is executed on each candidate record, and if it returns true the record</span>
  <span class="c1"># will be added to the scope.</span>

  <span class="c1"># Instead of a client proc you can provide a select proc, which will receive the entire</span>
  <span class="c1"># collection which can then be filtered and sorted.</span>

  <span class="n">scope</span> <span class="ss">:sort_by_created_at</span><span class="p">,</span>
        <span class="o">-&gt;</span> <span class="p">{</span> <span class="n">order</span><span class="p">(</span><span class="s1">'created_at DESC'</span><span class="p">)</span> <span class="p">}</span>
        <span class="ss">select: </span><span class="o">-&gt;</span> <span class="p">{</span> <span class="n">sort</span> <span class="p">{</span> <span class="o">|</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">|</span> <span class="n">b</span><span class="p">.</span><span class="nf">created_at</span> <span class="o">&lt;=&gt;</span> <span class="n">a</span><span class="p">.</span><span class="nf">created_at</span> <span class="p">}}</span>

  <span class="c1"># To keep things tidy you can specify the server scope proc with the :server option</span>

  <span class="n">scope</span> <span class="ss">:completed</span><span class="p">,</span>
        <span class="ss">server: </span><span class="o">-&gt;</span> <span class="p">{</span> <span class="n">where</span><span class="p">(</span><span class="ss">complete: </span><span class="kp">true</span><span class="p">)</span> <span class="p">}</span>
        <span class="ss">client: </span><span class="o">-&gt;</span> <span class="p">{</span> <span class="n">complete</span> <span class="p">}</span>

  <span class="c1"># The expressions in the joins array can be arbitrary sequences of relationships and</span>
  <span class="c1"># scopes such as 'comments.author'.  </span>

  <span class="n">scope</span> <span class="ss">:with_managers_comments</span><span class="p">,</span>
        <span class="ss">server: </span><span class="o">-&gt;</span> <span class="p">{</span> <span class="p">.</span><span class="nf">.</span><span class="o">.</span> <span class="p">}</span>
        <span class="ss">joins: </span><span class="p">[</span><span class="s1">'comments.author'</span><span class="p">,</span> <span class="s1">'owner'</span><span class="p">]</span>
        <span class="ss">client: </span><span class="o">-&gt;</span> <span class="p">{</span> <span class="n">comments</span><span class="p">.</span><span class="nf">detect</span> <span class="p">{</span> <span class="o">|</span><span class="n">comment</span><span class="o">|</span> <span class="n">comment</span><span class="p">.</span><span class="nf">author</span> <span class="o">==</span> <span class="n">owner</span><span class="p">.</span><span class="nf">manager</span> <span class="p">}}}</span>

  <span class="c1"># You can also use the client, select, server, and joins option with the default_scope macro</span>

  <span class="n">default_scope</span> <span class="ss">server: </span><span class="o">-&gt;</span> <span class="p">{</span> <span class="n">where</span><span class="p">(</span><span class="ss">deleted: </span><span class="kp">false</span><span class="p">).</span><span class="nf">order</span><span class="p">(</span><span class="s1">'updated_at DESC'</span><span class="p">)</span> <span class="p">}</span>
                <span class="ss">select: </span><span class="o">-&gt;</span> <span class="p">{</span> <span class="nb">select</span> <span class="p">{</span> <span class="o">|</span><span class="n">r</span><span class="o">|</span> <span class="o">!</span><span class="n">r</span><span class="p">.</span><span class="nf">deleted</span> <span class="p">}.</span><span class="nf">sort</span> <span class="p">{</span> <span class="o">|</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">|</span> <span class="n">b</span> <span class="o">&lt;=&gt;</span> <span class="n">a</span> <span class="p">}</span> <span class="p">}</span>

  <span class="c1"># NOTE: it is highly recommend to provide a client proc with default_scopes.  Otherwise</span>
  <span class="c1"># every change is going to require a server interaction regardless of what other client procs</span>
  <span class="c1"># you provide.</span>

<span class="k">end</span>
</code></pre>
<h4 id="how-it-works">How it works</h4>

<p>Consider this scope on the Todo model</p>
<pre class="highlight ruby"><code><span class="n">scope</span> <span class="ss">:with_managers_comments</span><span class="p">,</span>
      <span class="ss">server: </span><span class="o">-&gt;</span> <span class="p">{</span> <span class="n">joins</span><span class="p">(</span><span class="ss">owner: :manager</span><span class="p">,</span> <span class="ss">comments: :author</span><span class="p">).</span><span class="nf">where</span><span class="p">(</span><span class="s1">'managers_users.id = authors_comments.id'</span><span class="p">).</span><span class="nf">distinct</span> <span class="p">},</span>
      <span class="ss">client: </span><span class="o">-&gt;</span> <span class="p">{</span> <span class="n">comments</span><span class="p">.</span><span class="nf">detect</span> <span class="p">{</span> <span class="o">|</span><span class="n">comment</span><span class="o">|</span> <span class="n">comment</span><span class="p">.</span><span class="nf">author</span> <span class="o">==</span> <span class="n">owner</span><span class="p">.</span><span class="nf">manager</span> <span class="p">}}</span>
      <span class="ss">joins: </span><span class="p">[</span><span class="s1">'comments.author'</span><span class="p">,</span> <span class="s1">'owner'</span><span class="p">]</span>
</code></pre>
<p>The joins <code>comments.author</code> relationship is inverted so that we have User <code>has_many</code> Comments which <code>belongs_to</code> Todos.</p>

<p>Thus we now know that whenever a User or a Comment changes this may effect our with<em>managers</em>comments scope. Likewise <code>owner</code> becomes User <code>has_many</code> Todos.</p>

<p>Lets say that a user changes teams and now has a new manager. This means according to the relationships that the User model will change (i.e. there will be a new manager_id in the User model) and thus all Todos belonging to that User are subject to evaluation.</p>

<p>While the server side proc efficiently delivers all the objects in the scope, the client side proc just needs to incrementally update the scope.</p>

        </div>
      </div>
    </div>

    <script>
      (function(Opal) {
        var self = Opal.top, $scope = Opal, nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice;
        Opal.add_stubs(['$puts']);
        return self.$puts("Opal ok")
      })(Opal);
    </script>

    <!-- <script   src="http://code.jquery.com/jquery-3.1.1.min.js"   integrity="sha256-hVVnYaiADRTO2PzUGmuLJr8BLUSjGIZsDYGmIJLv2b8="   crossorigin="anonymous"></script> -->

    <script type="text/ruby">puts "Hyperloop Express ok"</script>

    <script type="text/ruby">

class CodeMirror < React::Component::Base
  param :code, type: String
  define_state :error_message

  before_mount do
    state.error_message! ""
  end

  after_mount do
    @editor = `CodeMirror(document.getElementById("code"), {
      value: #{params.code},
      mode: "text/x-ruby",
      matchBrackets: true,
      lineNumbers: true,
      indentUnit: 2,
      theme: 'github'
    });`
    `#{@editor}.on('change', #{lambda {on_change} })`
    execute_code
  end

  render(DIV) do
    div(id: 'code')
    br
    div(id: 'result')
    p { state.error_message }
  end

  def on_change
    state.error_message! ""
    execute_code
  end

  after_mount   :execute_code
  after_update  :execute_code

  def execute_code
    compiled_code = Opal::Compiler.new(`#{@editor}.getValue()`).compile
    `ReactDOM.unmountComponentAtNode(document.getElementById("result"));`
    `eval(#{compiled_code})`
    Element['#result'].render{ Alfie() }
    rescue Exception => e
    @time_out = after(0.5) do
      state.error_message! e.message
    end
  end

end

class TestApp < React::Component::Base
  param :name
  before_mount { @timer = every(1) { force_update! } }
  render(DIV) do
    h1 {"The current time is #{Time.now}"}
    h2 { "here hello #{params.name}" }.on(:click) do
     alert "you clicked"
    end
  end
end

</script>


  </body>
</html>
